OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:58.994938-04:00' ],		#prior : OmReference [ 'Pharo9.0-SNAPSHOT-64bit-1570116.ecqra8yva9mqcmvv1cbo6ma57', '7' ],		#self : OmReference [ '1' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'SSimpleFitnessFunction',				#definitionSource : 'SSimpleFitnessFunction subclass: #SBranchCoverage\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'SmallSuiteGenerator-GA\''			},			#name : #SBranchCoverage,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'SBranchCoverage class\r\tinstanceVariableNames: \'\''				},				#name : #'SBranchCoverage class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #SBranchCoverage				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #SmallSuiteGenerator-GA,			#package : #SmallSuiteGenerator,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:58.996715-04:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'SSimpleFitnessFunction',				#definitionSource : 'SSimpleFitnessFunction subclass: #SOutputCoverage\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'SmallSuiteGenerator-GA\''			},			#name : #SOutputCoverage,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'SOutputCoverage class\r\tinstanceVariableNames: \'\''				},				#name : #'SOutputCoverage class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #SOutputCoverage				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #SmallSuiteGenerator-GA,			#package : #SmallSuiteGenerator,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.025231-04:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'SGAObject',				#definitionSource : 'SGAObject subclass: #SGAEngine\r\tinstanceVariableNames: \'populationSize mutationOperator crossoverOperator numberOfStatements population logs typeInfo fitness selectionStrategy numberOfGenerations targetClassName lastMessage packageRegex initialPopulation typeInfoProfiler targetPackageRegex elitismRate crossoverStrategy stopIterations totalExecutionGA selectionStrategyTestCase\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'SmallSuiteGenerator-GA\''			},			#name : #SGAEngine,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #populationSize,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #mutationOperator,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #crossoverOperator,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #numberOfStatements,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #population,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #logs,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #typeInfo,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #fitness,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #selectionStrategy,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #numberOfGenerations,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #targetClassName,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #lastMessage,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #packageRegex,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #initialPopulation,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #typeInfoProfiler,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #targetPackageRegex,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #elitismRate,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #crossoverStrategy,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #stopIterations,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #totalExecutionGA,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #selectionStrategyTestCase,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'SGAEngine class\r\tinstanceVariableNames: \'\''				},				#name : #'SGAEngine class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #SGAEngine				},				#parent : @7,				#content : 'SGAEngine is responsible for executing the genetic algorithm, it means that it follows the phases to get a testCase population with the highest fitness score.\r\rThe phases followed are:\r\t1. Create an initial population \r\t2. Use the fitness function established to calculate the fitness score of each testCase in the population\r\t3. Determine the selection strategy to select the fittest testCases and let them pass their statements to the next generation\r\t4. Apply the crossover operation to get offsprings (new testCases) by exchanging the statements of parents (testCases). \r\t5. Apply mutation operation with a low random probability to modify some statements.\r \rInternal Representation and Key Implementation Points.\r\rInstance Variables\r\r\tcrossoverOperator:\t\t\t<SGACrossoverOperator>\r\tfitness:\t\t\t\t\t\t<SFitnessFunction>\r\tlogs:\t\t\t\t\t\t\t<OrderedCollection>\r\tmutationOperator:\t\t\t<SGAMutationOperator>\r\tnumberOfIterations:\t\t<SmallInteger>\r\tnumberOfStatements:\t\t<SmallInteger>\r\tpopulation:\t\t\t\t\t<OrderedCollection>\r\tpopulationSize:\t\t\t\t<SmallInteger>\r\tselectionStrategy:\t\t\t<SGATournamentSelection>\r\ttargetClassName:\t\t\t<ByteString>\r\ttypeInfo:\t\t\t\t\t\t<STypeInfo>',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #SmallSuiteGenerator-GA,			#package : #SmallSuiteGenerator,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'SGAObject',				#definitionSource : 'SGAObject subclass: #SGAEngine\r\tinstanceVariableNames: \'populationSize mutationOperator crossoverOperator numberOfStatements population logs typeInfo fitness selectionStrategy numberOfGenerations targetClassName lastMessage packageRegex initialPopulation typeInfoProfiler targetPackageRegex elitismRate crossoverStrategy stopIterations totalExecutionGA selectionStrategyTestCase generatedClass\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'SmallSuiteGenerator-GA\''			},			#name : #SGAEngine,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #populationSize,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #mutationOperator,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #crossoverOperator,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #numberOfStatements,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #population,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #logs,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #typeInfo,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #fitness,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #selectionStrategy,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #numberOfGenerations,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #targetClassName,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #lastMessage,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #packageRegex,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #initialPopulation,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #typeInfoProfiler,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #targetPackageRegex,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #elitismRate,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #crossoverStrategy,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #stopIterations,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #totalExecutionGA,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #selectionStrategyTestCase,					#parent : @63				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SGAEngine					},					#name : #generatedClass,					#parent : @63				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'SGAEngine class\r\tinstanceVariableNames: \'\''				},				#name : #'SGAEngine class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @63			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #SGAEngine				},				#parent : @63,				#content : 'SGAEngine is responsible for executing the genetic algorithm, it means that it follows the phases to get a testCase population with the highest fitness score.\r\rThe phases followed are:\r\t1. Create an initial population \r\t2. Use the fitness function established to calculate the fitness score of each testCase in the population\r\t3. Determine the selection strategy to select the fittest testCases and let them pass their statements to the next generation\r\t4. Apply the crossover operation to get offsprings (new testCases) by exchanging the statements of parents (testCases). \r\t5. Apply mutation operation with a low random probability to modify some statements.\r \rInternal Representation and Key Implementation Points.\r\rInstance Variables\r\r\tcrossoverOperator:\t\t\t<SGACrossoverOperator>\r\tfitness:\t\t\t\t\t\t<SFitnessFunction>\r\tlogs:\t\t\t\t\t\t\t<OrderedCollection>\r\tmutationOperator:\t\t\t<SGAMutationOperator>\r\tnumberOfIterations:\t\t<SmallInteger>\r\tnumberOfStatements:\t\t<SmallInteger>\r\tpopulation:\t\t\t\t\t<OrderedCollection>\r\tpopulationSize:\t\t\t\t<SmallInteger>\r\tselectionStrategy:\t\t\t<SGATournamentSelection>\r\ttargetClassName:\t\t\t<ByteString>\r\ttypeInfo:\t\t\t\t\t\t<STypeInfo>',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #SmallSuiteGenerator-GA,			#package : #SmallSuiteGenerator,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.045097-04:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'SSTestShifter',				#definitionSource : 'SSTestShifter subclass: #SSTestCase\r\tinstanceVariableNames: \'fitness idPopulation summaryExecutionMethods generationNumber summaryTargetClass fitnessByClass selectionStrategy parents children properties\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'SmallSuiteGenerator-Core\''			},			#name : #SSTestCase,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #fitness,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #idPopulation,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #summaryExecutionMethods,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #generationNumber,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #summaryTargetClass,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #fitnessByClass,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #selectionStrategy,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #parents,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #children,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #properties,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'SSTestCase class\r\tinstanceVariableNames: \'\''				},				#name : #'SSTestCase class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #SSTestCase				},				#parent : @7,				#content : 'SSTestCase is a subclass that defines or initializes some instance variables which are util in the genetic algorithm evolution',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #SmallSuiteGenerator-Core,			#package : #SmallSuiteGenerator,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#superclassName : 'SSTestShifter',				#definitionSource : 'SSTestShifter subclass: #SSTestCase\r\tinstanceVariableNames: \'fitness idPopulation summaryExecutionMethods generationNumber summaryTargetClass fitnessByClass selectionStrategy parents children properties multiFitnessByClass\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'SmallSuiteGenerator-Core\''			},			#name : #SSTestCase,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #fitness,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #idPopulation,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #summaryExecutionMethods,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #generationNumber,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #summaryTargetClass,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #fitnessByClass,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #selectionStrategy,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #parents,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #children,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #properties,					#parent : @41				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SSTestCase					},					#name : #multiFitnessByClass,					#parent : @41				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'SSTestCase class\r\tinstanceVariableNames: \'\''				},				#name : #'SSTestCase class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @41			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#isMetaSide : false,					#className : #SSTestCase				},				#parent : @41,				#content : 'SSTestCase is a subclass that defines or initializes some instance variables which are util in the genetic algorithm evolution',				#stamp : ''			},			#classVariables : OrderedCollection [ ],			#category : #SmallSuiteGenerator-Core,			#package : #SmallSuiteGenerator,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.078085-04:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'SMultiFitnessFunction class'			},			#name : #methodAndStatementCoverage,			#protocol : #'instance creation',			#sourceCode : 'methodAndStatementCoverage\r\t| inst |\r\t\r\tinst := self new.\r\tinst add: SMethodCoverage new weight: 0.6.\r\tinst add: SStatementCoverage new weight: 0.4.\r\t^ inst',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'SMultiFitnessFunction class'			},			#name : #methodAndStatementCoverage,			#protocol : #'as yet unclassified',			#sourceCode : 'methodAndStatementCoverage\r\t| inst |\r\t\r\tinst := self new.\r\tinst add: SMethodCoverage new weight: 0.6.\r\tinst add: SStatementCoverage new weight: 0.4.\r\t^ inst',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.078789-04:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'SMultiFitnessFunction class'			},			#name : #methodAndStatementCoverage,			#protocol : #'instance creation',			#sourceCode : 'methodAndStatementCoverage\r\t| inst |\r\t\r\tinst := self new.\r\tinst add: SMethodCoverage new weight: 0.6.\r\tinst add: SStatementCoverage new weight: 0.4.\r\t^ inst',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.080533-04:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpProtocolRemoval {		#behavior : RGMetaclassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'SMultiFitnessFunction class\r\tinstanceVariableNames: \'multiFitnessFunction\''			},			#name : #'SMultiFitnessFunction class',			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGClassInstanceVariableDefinition {					#annotations : IdentityDictionary {						#isMetaSide : true,						#className : #'SMultiFitnessFunction class'					},					#name : #multiFitnessFunction,					#parent : @7				}			],			#baseClass : RGClassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#superclassName : 'SFitnessFunction',					#definitionSource : 'SFitnessFunction subclass: #SMultiFitnessFunction\r\tinstanceVariableNames: \'functionList\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'SmallSuiteGenerator-GA\''				},				#name : #SMultiFitnessFunction,				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGInstanceVariableDefinition {						#annotations : IdentityDictionary {							#isMetaSide : false,							#className : #SMultiFitnessFunction						},						#name : #functionList,						#parent : @14					}				],				#metaClass : @7,				#comment : RGCommentDefinition {					#annotations : IdentityDictionary {						#isMetaSide : false,						#className : #SMultiFitnessFunction					},					#parent : @14,					#content : 'SMultiFitnessFunciton is the fitness function that contains simple fitness function\'s collection.',					#stamp : ''				},				#classVariables : OrderedCollection [ ],				#category : #SmallSuiteGenerator-GA,				#package : #SmallSuiteGenerator,				#sharedPools : OrderedCollection [ ]			}		},		#protocol : #'instance creation'	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.085165-04:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SZoomInAction			},			#name : #execute,			#protocol : #hooks,			#sourceCode : 'execute\r\t| canvas keyNavigation |\r\tcanvas := self roassalCanvas.\r\tkeyNavigation := canvas controllerInteraction interactions at: RSKeyNavigationCanvas.\r\tkeyNavigation zoomIn: canvas',			#stamp : '',			#package : #SmallSuiteGenerator-Visualization		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SZoomInAction			},			#name : #execute,			#protocol : #hooks,			#sourceCode : 'execute\r\t| canvas keyNavigation |\r\tcanvas := self roassalCanvas.\r\tkeyNavigation := canvas controllerInteraction interactions at: RSKeyNavigationCanvasInteraction.\r\tkeyNavigation zoomIn: canvas',			#stamp : '',			#package : #SmallSuiteGenerator-Visualization		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.085528-04:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SZoomOutAction			},			#name : #execute,			#protocol : #hooks,			#sourceCode : 'execute\r\t| canvas keyNavigation |\r\tcanvas := self roassalCanvas.\r\tkeyNavigation := canvas controllerInteraction interactions at: RSKeyNavigationCanvas.\r\tkeyNavigation zoomOut: canvas',			#stamp : '',			#package : #SmallSuiteGenerator-Visualization		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SZoomOutAction			},			#name : #execute,			#protocol : #hooks,			#sourceCode : 'execute\r\t| canvas keyNavigation |\r\tcanvas := self roassalCanvas.\r\tkeyNavigation := canvas controllerInteraction interactions at: RSKeyNavigationCanvasInteraction.\r\tkeyNavigation zoomOut: canvas',			#stamp : '',			#package : #SmallSuiteGenerator-Visualization		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.085888-04:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SFitnessFunction			},			#name : #'run:',			#protocol : #actions,			#sourceCode : 'run: testCaseCollection\r\r\ttestCaseCollection\r\t\tdo: [ :testCase | \r\t\t\ttestCase length > 0 ifTrue: [\r\t\t\t\tprofiler cleanBlocksOfMethods.\r\t\t\t\ttestCase runWithoutAssertionsAndLastStatement.\r\t\t\t\tSGAEngine logClass summaryExecutionMethodsOf: testCase with: profiler.\r\t\t\t\tself fitnessOf: testCase. ]\r\t\t\tifFalse: [ testCase fitness at: self functionName put: 0 ] ]',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SFitnessFunction			},			#name : #'run:',			#protocol : #actions,			#sourceCode : 'run: testCaseCollection\r\r\ttestCaseCollection\r\t\tdo: [ :testCase | \r\t\t\ttestCase length > 0 ifTrue: [\r\t\t\t\tprofiler cleanBlocksOfMethods.\r\t\t\t\ttestCase runWithoutAssertionsAndLastStatement.\r\t\t\t\tSGAEngine logClass summaryExecutionMethodsOf: testCase with: profiler.\r\t\t\t\tself fitnessOf: testCase ]\r\t\t\tifFalse: [ testCase fitness at: self functionName put: 0 ] ]',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.086042-04:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'SMultiFitnessFunction class'			},			#name : #multiCoverage,			#protocol : #'instance creation',			#sourceCode : 'multiCoverage\r  | inst |\r  inst := self new.\r  inst add: SBranchCoverage new weight: 0.2.\r  inst add: SMethodCoverage new weight: 0.5.\r  inst add: SStatementCoverage new weight: 0.3.\r  ^inst',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.086155-04:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SBranchCoverage			},			#name : #'coverageCriteria:',			#protocol : #'as yet unclassified',			#sourceCode : 'coverageCriteria: className\r  ^profiler branchCoverageCriteriaOf: className',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.086251-04:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SBranchCoverage			},			#name : #fitnessByClass,			#protocol : #actions,			#sourceCode : 'fitnessByClass\r  ^ profiler branchCoverage',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.086327-04:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SBranchCoverage			},			#name : #functionName,			#protocol : #accesing,			#sourceCode : 'functionName\r  ^ \'branch-coverage\'',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.086406-04:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SMethodCoverage			},			#name : #'coverageCriteria:',			#protocol : #'as yet unclassified',			#sourceCode : 'coverageCriteria: className\r  ^profiler methodCoverageCriteriaOf: className',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.086476-04:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SOutputCoverage			},			#name : #'coverageCriteria:',			#protocol : #'as yet unclassified',			#sourceCode : 'coverageCriteria: className\r  ^profiler outputCoverageCriteriaOf: className',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.086545-04:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SOutputCoverage			},			#name : #fitnessByClass,			#protocol : #actions,			#sourceCode : 'fitnessByClass\r  ^ profiler outputCoverage',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.086617-04:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SOutputCoverage			},			#name : #functionName,			#protocol : #accesing,			#sourceCode : 'functionName\r  ^\'output-coverage\'',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.086697-04:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'SSimpleFitnessFunction class'			},			#name : #'profiler:',			#protocol : #accessing,			#sourceCode : 'profiler: aProfiler\r\t^ self new profiler: aProfiler ',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.086772-04:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SSimpleFitnessFunction			},			#name : #'coverageCriteria:',			#protocol : #'as yet unclassified',			#sourceCode : 'coverageCriteria: className\r  ^self subclassResponsibility',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.08703-04:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SSimpleFitnessFunction			},			#name : #'fitnessOf:',			#protocol : #actions,			#sourceCode : 'fitnessOf: testCase\r\t| fitness |\r\t\r\tfitness := self computeFitness.\r\ttestCase fitness at: self functionName put: fitness first.\r\ttestCase fitnessByClass at: self functionName put: fitness second.',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SSimpleFitnessFunction			},			#name : #'fitnessOf:',			#protocol : #actions,			#sourceCode : 'fitnessOf: testCase\r\t| fitness |\r  fitness := self computeFitness.\r  testCase fitness at: self functionName put: fitness first.\r  testCase fitnessByClass at: self functionName put: fitness second',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.087109-04:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SSimpleFitnessFunction			},			#name : #'multiFitnessByClassOf:',			#protocol : #actions,			#sourceCode : 'multiFitnessByClassOf: testCase\r  SSimpleFitnessFunction subclasses do: [:subClass |  | instance |\r        instance := subClass profiler: profiler.\r        testCase multiFitnessByClass at: instance functionName put: (instance coverageCriteria: testCase targetClassesName) ].\r\ttestCase multiFitnessByClass ifEmpty: [ self halt ]',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.087376-04:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SSimpleFitnessFunction			},			#name : #'run:',			#protocol : #actions,			#sourceCode : 'run: testCaseCollection\r\r\ttestCaseCollection\r\t\tdo: [ :testCase | \r\t\t\ttestCase length > 0 ifTrue: [\r\t\t\t\tprofiler cleanBlocksOfMethods.\r\t\t\t\ttestCase runWithoutAssertionsAndLastStatement.\r\t\t\t\tSGAEngine logClass summaryExecutionMethodsOf: testCase with: profiler.\r\t\t\t\tself fitnessOf: testCase. ]\r\t\t\tifFalse: [ testCase fitness at: self functionName put: 0 ] ]\r\t',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SSimpleFitnessFunction			},			#name : #'run:',			#protocol : #actions,			#sourceCode : 'run: testCaseCollection\r  testCaseCollection do: [:testCase |  testCase length > 0 ifTrue: [ profiler cleanBlocksOfMethods.\r              testCase runWithoutAssertionsAndLastStatement.\r              SGAEngine logClass summaryExecutionMethodsOf: testCase with: profiler.\r              self fitnessOf: testCase.\r\t\t\t\t  self multiFitnessByClassOf: testCase\r\t\t\t\t\t ] ifFalse: [ testCase fitness at: self functionName put: 0 ] ]',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.087452-04:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SStatementCoverage			},			#name : #'coverageCriteria:',			#protocol : #'as yet unclassified',			#sourceCode : 'coverageCriteria: className\r  ^profiler statementCoverageCriteriaOf: className',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.087688-04:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SStatementCoverage			},			#name : #functionName,			#protocol : #accesing,			#sourceCode : 'functionName\r\r\t^ \'block-coverage\'',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SStatementCoverage			},			#name : #functionName,			#protocol : #accesing,			#sourceCode : 'functionName\r  ^\'statement-coverage\'',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.087831-04:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAEngine			},			#name : #'addResultEvolutionToLog:',			#protocol : #'as yet unclassified',			#sourceCode : 'addResultEvolutionToLog: stream\r  | assocs dictFitness lastLog |\r  assocs := OrderedCollection new\r     add: \'LINE\' -> \'statement-coverage\';\r     add: \'BRANCH\' -> \'branch-coverage\';\r     add: \'OUTPUT\' -> \'output-coverage\';\r     add: \'METHOD\' -> \'method-coverage\';\r     yourself.\r  lastLog := logs last.\r  dictFitness := lastLog fittestTestCase multiFitnessByClass.\r  stream\r     nextPutAll: \'Minimizing test suite\';\r     nextPut: Character cr;\r     nextPutAll: \'Coing to analyze the coverage criteria\';\r     nextPut: Character cr.\r  dictFitness \r\tifEmpty: [ self halt ]\rifNotEmpty: [ assocs do: [:assoc |  | array |\r              array := dictFitness at: assoc value.\r              stream\r                 nextPutAll: \'Coverage analysis for criterion \';\r                 nextPutAll: assoc key;\r                 nextPut: Character cr;\r                 nextPutAll: \'Coverage of criterion \';\r                 nextPutAll: assoc key;\r                 nextPutAll: \': \';\r                 nextPutAll: array third asString;\r                 nextPut: $%;\r                 nextPut: Character cr;\r                 nextPutAll: \'Total number of goals: \';\r                 nextPutAll: array first asString;\r                 nextPut: Character cr;\r                 nextPutAll: \'Number of covered goals: \';\r                 nextPutAll: array second asString;\r                 nextPut: Character cr ] ].\r  stream\r     nextPutAll: \'Generated \';\r     nextPutAll: generatedClass methods size asString;\r     nextPutAll: \' tests\';\r     nextPut: Character cr.\r  dictFitness ifNotEmpty: [ stream\r           nextPutAll: \'Resulting test suites coverage: \';\r           nextPutAll: ((dictFitness values collect: #third) sum / (dictFitness size * 100) * 100 asFloat round: 3) asString;\r           nextPutAll: \'% (average coverage for all fitness functiones)\';\r           nextPut: Character cr ].\r  stream\r     nextPutAll: \'Writing test case \';\r     nextPutAll: generatedClass name',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.087921-04:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAEngine			},			#name : #'addSelectionAlgorithmToLog:',			#protocol : #'as yet unclassified',			#sourceCode : 'addSelectionAlgorithmToLog: stream\r  stream\r     nextPutAll: \'Setting up search algorithm for whole suite generation: \';\r     nextPutAll: selectionStrategy class name;\r     nextPut: Character cr',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.088018-04:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAEngine			},			#name : #'addTestCriteriaToLog:',			#protocol : #'as yet unclassified',			#sourceCode : 'addTestCriteriaToLog: stream\r  stream\r     nextPutAll: \'* Test criteria:\';\r     nextPut: Character cr;\r     nextPutAll: \'    - Line coverage\';\r     nextPut: Character cr;\r     nextPutAll: \'    - Branch coverage\';\r     "nextPut: Character cr;\r     nextPutAll: \'    - Exception\';\r     nextPut: Character cr;\r     nextPutAll: \'    - Mutation testing\';"\r     nextPut: Character cr;\r     nextPutAll: \'    - Method-Output Coverage\';\r     nextPut: Character cr;\r     nextPutAll: \'    - Top-Level Method Coverage\';\r     "nextPut: Character cr;\r     nextPutAll: \'    - No-Exception Top-Level Method Coverage\';\r     nextPut: Character cr;\r     nextPutAll: \'    - Context Branch Coverage\';"\r     nextPut: Character cr',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.088108-04:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAEngine			},			#name : #'addTestGoalsToLog:',			#protocol : #'as yet unclassified',			#sourceCode : 'addTestGoalsToLog: stream\r  stream\r     nextPutAll: \'Search finished after \';\r     nextPutAll: (totalExecutionGA / 1000) asFloat asString;\r     nextPut: $s;\r     nextPutAll: \' and \';\r     nextPutAll: numberOfGenerations asString;\r     nextPutAll: \' generations, \';\r     nextPutAll: \'best individual has fitness: \';\r     nextPutAll: logs last fittestTestCase fitness values first asString;\r\t  nextPut: $%;\r     nextPut: Character cr',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.088431-04:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAEngine			},			#name : #createRandomPopulation,			#protocol : #creating,			#sourceCode : 'createRandomPopulation\r\r\t^ (1 to: populationSize) collect: [:idPop |  | value test |\r        value := self next * numberOfStatements + 1.\r        test := SSTestCase with: typeInfo.\r        test\r           targetClassName: targetClassName;\r           addFactoryMessage: targetClassName;\r           generateStatements: value;\r           lastMessage: lastMessage;\r           idPopulation: idPop;\r\t\t\t  clean.\r\t\t  selectionStrategyTestCase ifNotNil: [ test selectionStrategy: selectionStrategyTestCase ].\r        test ]',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAEngine			},			#name : #createRandomPopulation,			#protocol : #creating,			#sourceCode : 'createRandomPopulation\r  ^(1 to: populationSize) collect: [:idPop |  | value test |\r        value := (self next * numberOfStatements + 1) asInteger.\r        test := SSTestCase with: typeInfo.\r        test\r           targetClassName: targetClassName;\r           addFactoryMessage: targetClassName;\r           generateStatements: value;\r           lastMessage: lastMessage;\r           idPopulation: idPop;\r           clean.\r        selectionStrategyTestCase ifNotNil: [ test selectionStrategy: selectionStrategyTestCase ].\r        test ]',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.088526-04:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAEngine			},			#name : #'generatedClass:',			#protocol : #accessing,			#sourceCode : 'generatedClass: aClass \r\tgeneratedClass := aClass',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.088822-04:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAEngine			},			#name : #initializePopulation,			#protocol : #initialization,			#sourceCode : 'initializePopulation\r\t| t |\r\t\r\tt := Time now asSeconds.\r\tpopulation ifNil: [\r\t   population := self createRandomPopulation.\r \t   SExpression resetId.\r  \t\tself computeFitness.\r   \t\tpopulation := self order: population.\r   \t\tinitialPopulation := population.\r\t\tself updateTypeInfoWith: population.\r\t\tlogs add: (self logClass logOf: self inGeneration: 0 inTime: t).\r\t]',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAEngine			},			#name : #initializePopulation,			#protocol : #initialization,			#sourceCode : 'initializePopulation\r  | t |\r  t := Time now asSeconds.\r  population ifNil: [ population := self createRandomPopulation.\r        SExpression resetId.\r        self computeFitness.\r        population := self order: population.\r        initialPopulation := population.\r        self updateTypeInfoWith: population.\r        logs add: (self logClass logOf: self inGeneration: 0 inTime: t) ]',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.08892-04:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAEngine			},			#name : #saveSummaryLog,			#protocol : #'as yet unclassified',			#sourceCode : 'saveSummaryLog\r  | stream logName |\r\tlogName := targetClassName , \'Log.log\'.\r  logName asFileReference ensureDelete.\r  stream := logName asFileReference writeStream.\r  [ stream\r     nextPutAll: \'TestEvoViz\';\r     nextPut: Character cr;\r     nextPutAll: \'* Generating tests cases for class: \';\r     nextPutAll: targetClassName;\r     nextPut: Character cr.\r  self addTestCriteriaToLog: stream.\r  self addSelectionAlgorithmToLog: stream.\r  self addTestGoalsToLog: stream.\r  self addResultEvolutionToLog: stream.\r  stream\r     nextPut: Character cr;\r     nextPutAll: \'Done !\' ] ensure: [ stream close ]',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.089174-04:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'SConfigGenerationTestCase class'			},			#name : #fitness,			#protocol : #settings,			#sourceCode : 'fitness\r\r\t^ #statement',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'SConfigGenerationTestCase class'			},			#name : #fitness,			#protocol : #settings,			#sourceCode : 'fitness\r\r\t^ #branch',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.089456-04:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'SConfigGenerationTestCase class'			},			#name : #fitnessDictionary,			#protocol : #settings,			#sourceCode : 'fitnessDictionary\r\r\t^ Dictionary new\r\t\tat: #statement put: [SStatementCoverage new];\r\t\tat: #method put: [SMethodCoverage new];\r\t\tat: #multi put: [ SMultiFitnessFunction methodAndStatementCoverage ];\r\t\tyourself',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'SConfigGenerationTestCase class'			},			#name : #fitnessDictionary,			#protocol : #settings,			#sourceCode : 'fitnessDictionary\r  ^Dictionary new\r\t  at: #branch put: [ SBranchCoverage new ];\r     at: #statement put: [ SStatementCoverage new ];\r     at: #method put: [ SMethodCoverage new ];\r     at: #multi put: [ SMultiFitnessFunction multiCoverage ];\r     yourself',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.089712-04:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'SConfigGenerationTestCase class'			},			#name : #fitnessValue,			#protocol : #settings,			#sourceCode : 'fitnessValue\r\t"returns the fitness value given a keyword"\r\t\r\t^ (self fitnessDictionary \r\t\tat: self fitness \r\t\tifAbsent: [ self fitnessDictionary at: #statement ]) value',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : true,				#className : #'SConfigGenerationTestCase class'			},			#name : #fitnessValue,			#protocol : #settings,			#sourceCode : 'fitnessValue\r\t"returns the fitness value given a keyword"\r\t\r\t^ (self fitnessDictionary \r\t\tat: self fitness \r\t\tifAbsent: [ self fitnessDictionary at: #branch ]) value',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.08998-04:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #STestCaseFactory			},			#name : #run,			#protocol : #actions,			#sourceCode : 'run\r\tengine run.\r\t',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #STestCaseFactory			},			#name : #run,			#protocol : #actions,			#sourceCode : 'run\r  engine run;\r\tgeneratedClass: self generatedClass\r   "saveSummaryLog"',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.092798-04:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAViz			},			#name : #'addTickY:withScale:xMax:ofColor:andPositions:',			#protocol : #'*SmallSuiteGenerator-Visualization',			#sourceCode : 'addTickY: composite withScale: xScale xMax: xMax ofColor: color andPositions: ys\r\tys doWithIndex: [ :y :index | \r\t\t| tick lbl |\r\t\ttick := RSLine new \r\t\t\tstartPoint: (xScale scale: 0)@y;\r\t\t\tcolor: color;\r\t\t\twidth: 10;\r\t\t\tendPoint: (xScale scale: (xMax * -0.03))@y;\r\t\t\tyourself.\r\t\tcomposite addShape: tick.\r\t\tlbl := RSLabel new \t\r\t\t\tfontSize: 30;\r\t\t\tcolor: color;\r\t\t\ttext: index.\r\t\tRSLocation new outer left move: lbl on: tick.\r\t\tcomposite addShape: lbl.\r\t].',			#stamp : '',			#package : #SmallSuiteGenerator-Visualization		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAViz			},			#name : #'addTickY:withScale:xMax:ofColor:andPositions:',			#protocol : #'*SmallSuiteGenerator-Visualization',			#sourceCode : 'addTickY: composite withScale: xScale xMax: xMax ofColor: color andPositions: ys\r\tys doWithIndex: [ :y :index | \r\t\t| tick lbl |\r\t\ttick := RSLine new \r\t\t\tstartPoint: (xScale scale: 0)@y;\r\t\t\tcolor: color;\r\t\t\twidth: 10;\r\t\t\tendPoint: (xScale scale: (xMax * -0.03))@y;\r\t\t\tyourself.\r\t\tcomposite addShape: tick.\r\t\tlbl := RSLabel new \t\r\t\t\tfontSize: xScale range second * 0.1;\r\t\t\tcolor: color;\r\t\t\ttext: index.\r\t\tRSLocation new outer left move: lbl on: tick.\r\t\tcomposite addShape: lbl.\r\t].',			#stamp : '',			#package : #SmallSuiteGenerator-Visualization		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.094002-04:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAViz			},			#name : #'evolutionShapeWith:ofColor:size:',			#protocol : #'*SmallSuiteGenerator-Visualization',			#sourceCode : 'evolutionShapeWith: yPositions ofColor: dictColor size: size\r\t| composite scale points axis spaceStick xMax yMax |\r\tcomposite := RSComposite new \r\t\tcolor: Color transparent.\r\txMax := self logs last fittestTestCase fitnessByClass values first at: self targetClassName.\r\tscale := NSScale linear \r\t\tdomain: (Array with: 0 with: xMax);\r\t\trange: (Array with: 0 with: size x).\r\tyMax := yPositions last.\r\tpoints := self evolutionPoints: yPositions, #(0) withScale: scale.\r\tspaceStick := yMax - (0.01 * size y).\r\taxis := RSPolyline new \r\t\tcolor: (dictColor at: \'axis\');\r\t\twidth: 10;\t\r\t\tcontrolPoints: ((Array with: 0@0 with: 0@spaceStick with: (scale scale:xMax)@spaceStick));\r\t\tyourself.\r\tcomposite addShape: axis; \r\t\taddShape: (RSPolyline new \r\t\t\tcontrolPoints: (points at: \'lowest\'); \r\t\t\tcolor: (dictColor at: \'lowestCoverage\');\r\t\t\twidth: 10; yourself);\r\t\taddShape: (RSPolyline new \r\t\t\tcontrolPoints: (points at: \'average\'); \r\t\t\tcolor: (dictColor at: \'averageCoverage\');\r\t\t\twidth: 10; yourself);\r\t\taddShape: (RSPolyline new \r\t\t\tcontrolPoints: (points at: \'fittest\'); \r\t\t\tcolor: (dictColor at: \'fittestCoverage\');\r\t\t\twidth: 10; yourself).\r\tself addTickX: composite withScale: scale color: (dictColor at: \'font\') y: yMax and: xMax @ size y.\r\tself addTickY: composite withScale: scale xMax: xMax ofColor: (dictColor at: \'font\') andPositions: yPositions.\r\t^ composite adjustToChildren',			#stamp : '',			#package : #SmallSuiteGenerator-Visualization		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAViz			},			#name : #'evolutionShapeWith:ofColor:size:',			#protocol : #'*SmallSuiteGenerator-Visualization',			#sourceCode : 'evolutionShapeWith: yPositions ofColor: dictColor size: size\r\t| composite scale points axis spaceStick xMax yMax |\r\tcomposite := RSComposite new \r\t\tcolor: Color transparent.\r\txMax := self logs last fittestTestCase fitnessByClass values first at: self targetClassName ifAbsent: [ 0 ].\r\tscale := NSScale linear \r\t\tdomain: (Array with: 0 with: xMax);\r\t\trange: (Array with: 0 with: size x).\r\tyMax := yPositions last.\r\tpoints := self evolutionPoints: yPositions, #(0) withScale: scale.\r\tspaceStick := yMax - (0.01 * size y).\r\taxis := RSPolyline new \r\t\tcolor: (dictColor at: \'axis\');\r\t\twidth: 10;\t\r\t\tcontrolPoints: ((Array with: 0@0 with: 0@spaceStick with: (scale scale:xMax)@spaceStick));\r\t\tyourself.\r\tcomposite addShape: axis; \r\t\taddShape: (RSPolyline new \r\t\t\tcontrolPoints: (points at: \'lowest\'); \r\t\t\tcolor: (dictColor at: \'lowestCoverage\');\r\t\t\twidth: 10; yourself);\r\t\taddShape: (RSPolyline new \r\t\t\tcontrolPoints: (points at: \'average\'); \r\t\t\tcolor: (dictColor at: \'averageCoverage\');\r\t\t\twidth: 10; yourself);\r\t\taddShape: (RSPolyline new \r\t\t\tcontrolPoints: (points at: \'fittest\'); \r\t\t\tcolor: (dictColor at: \'fittestCoverage\');\r\t\t\twidth: 10; yourself).\r\tself addTickX: composite withScale: scale color: (dictColor at: \'font\') y: yMax and: xMax @ size y.\r\tself addTickY: composite withScale: scale xMax: xMax ofColor: (dictColor at: \'font\') andPositions: yPositions.\r\t^ composite adjustToChildren',			#stamp : '',			#package : #SmallSuiteGenerator-Visualization		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.095099-04:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAViz			},			#name : #'testCaseShape:ofColor:with:highlight:scale:',			#protocol : #'*SmallSuiteGenerator-Visualization',			#sourceCode : 'testCaseShape: testCase ofColor: dictColor with: memo highlight: highlight scale: scaleColorBlock\r\r\t| group higher block progressValue methodGroup contribute |\r\tblock := [ :tC | [ tC fitnessByClass values first at: self targetClassName ifAbsent: 0 ] on: SubscriptOutOfBounds do: [ 0 ] ].\r\tprogressValue := block value: testCase.\r\thigher := testCase parents ifEmpty: [ false ] \r\t\tifNotEmpty: [ testCase parents allSatisfy: [ :tC | (block value: tC) < progressValue ] ].\r\tgroup := RSGroup new.\r\tmethodGroup := self methodShapeGroup: testCase with: memo highlight: highlight scale: scaleColorBlock.\r\tcontribute := methodGroup isNotEmpty or: [ higher ].\r\tgroup add: methodGroup;\r\t\tadd: (RSGroup new \r\t\t\tadd: (RSComposite new \r\t\t\t\taddShape: (RSLabel new text: progressValue asString, \'%\'; bold; \r\t\t\t\t\tcolor: ((dictColor at: \'fontMethodBox\') alpha: (contribute ifFalse: [ 0.5 ] ifTrue: [ 1 ])); fontSize: 20); \r\t\t\t\t\tpadding: (Margin left: 10 right: 10 top: 1 bottom: 1)); yourself).\r\tRSVerticalLineLayout on: group.\r\t^ RSComposite new \r\t\tshapes: (group flatCollect: #yourself);\r\t\tpaint: ((dictColor at: \'backgroundTestCase\') alpha: (contribute ifFalse: [ 0.5 ] ifTrue: [ 1 ]));\r\t\tmodel: testCase;\r\t\tborder: (RSBorder new width: (higher ifTrue: [ 8 ] ifFalse: [ 1 ]); color: (dictColor at: \'borderTestCase\'));\r\t\tpadding: 10;\r\t\tpopupText: testCase asString;\r\t\tdraggable ',			#stamp : '',			#package : #SmallSuiteGenerator-Visualization		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SGAViz			},			#name : #'testCaseShape:ofColor:with:highlight:scale:',			#protocol : #'*SmallSuiteGenerator-Visualization',			#sourceCode : 'testCaseShape: testCase ofColor: dictColor with: memo highlight: highlight scale: scaleColorBlock\r\r\t| group higher block progressValue methodGroup contribute |\r\tblock := [ :tC | [ tC fitnessByClass values first at: self targetClassName ifAbsent: [ 0 ] ] on: SubscriptOutOfBounds do: [ 0 ] ].\r\tprogressValue := block value: testCase.\r\thigher := testCase parents ifEmpty: [ false ] \r\t\tifNotEmpty: [ testCase parents allSatisfy: [ :tC | (block value: tC) < progressValue ] ].\r\tgroup := RSGroup new.\r\tmethodGroup := self methodShapeGroup: testCase with: memo highlight: highlight scale: scaleColorBlock.\r\tcontribute := methodGroup isNotEmpty or: [ higher ].\r\tgroup add: methodGroup;\r\t\tadd: (RSGroup new \r\t\t\tadd: (RSComposite new \r\t\t\t\taddShape: (RSLabel new text: progressValue asString, \'%\'; bold; \r\t\t\t\t\tcolor: ((dictColor at: \'fontMethodBox\') alpha: (contribute ifFalse: [ 0.5 ] ifTrue: [ 1 ])); fontSize: 20); \r\t\t\t\t\tpadding: (Margin left: 10 right: 10 top: 1 bottom: 1)); yourself).\r\tRSVerticalLineLayout on: group.\r\t^ RSComposite new \r\t\tshapes: (group flatCollect: #yourself);\r\t\tpaint: ((dictColor at: \'backgroundTestCase\') alpha: (contribute ifFalse: [ 0.5 ] ifTrue: [ 1 ]));\r\t\tmodel: testCase;\r\t\tborder: (RSBorder new width: (higher ifTrue: [ 8 ] ifFalse: [ 1 ]); color: (dictColor at: \'borderTestCase\'));\r\t\tpadding: 10;\r\t\tpopupText: testCase asString;\r\t\tdraggable ',			#stamp : '',			#package : #SmallSuiteGenerator-Visualization		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.095393-04:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SSTestCase			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'deepCopy\r\t| copy |\r\r\tcopy := self copy.\r\tcopy setFitness: self fitness.\r\tcopy setFitnessByClass: self fitnessByClass.\r\tcopy generationNumber: self generationNumber.\r\tcopy summaryExecutionMethods: self summaryExecutionMethods.\r\tcopy hasErrors: self hasErrors.\r\t^ copy',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SSTestCase			},			#name : #deepCopy,			#protocol : #copying,			#sourceCode : 'deepCopy\r\t| copy |\r\r\tcopy := self copy.\r\tcopy setFitness: self fitness.\r\tcopy setFitnessByClass: self fitnessByClass.\r\tcopy generationNumber: self generationNumber.\r\tcopy summaryExecutionMethods: self summaryExecutionMethods.\r\tcopy hasErrors: self hasErrors.\r\tcopy multiFitnessByClass: self multiFitnessByClass.\r\t^ copy',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.095686-04:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SSTestCase			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\r   super initialize.\r   generationNumber := 1.\r   idPopulation := 1.\r\tparents := OrderedCollection new.\r  \tchildren := OrderedCollection new.\r   summaryExecutionMethods := OrderedCollection new.\r\thasErrors := false.\r\tfitness := Dictionary new.\r\tfitnessByClass := Dictionary new.\r\tselectionStrategy := SGARouletteSelection new.\r\tproperties := Dictionary new.',			#stamp : '',			#package : #SmallSuiteGenerator		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SSTestCase			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r  super initialize.\r  generationNumber := 1.\r  idPopulation := 1.\r  parents := OrderedCollection new.\r  children := OrderedCollection new.\r  summaryExecutionMethods := OrderedCollection new.\r  hasErrors := false.\r  fitness := Dictionary new.\r  fitnessByClass := Dictionary new.\r\tmultiFitnessByClass := Dictionary new.\r  selectionStrategy := SGARouletteSelection new.\r  properties := Dictionary new',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.09578-04:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SSTestCase			},			#name : #multiFitnessByClass,			#protocol : #accessing,			#sourceCode : 'multiFitnessByClass\r\t^ multiFitnessByClass\t',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:01:59.095865-04:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SSTestCase			},			#name : #'multiFitnessByClass:',			#protocol : #accessing,			#sourceCode : 'multiFitnessByClass: dictionary \r\tmultiFitnessByClass := dictionary ',			#stamp : '',			#package : #SmallSuiteGenerator		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.332579-04:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLProfilerCoverage			},			#name : #branchCoverage,			#protocol : #calculations,			#sourceCode : 'branchCoverage\r  ^(self calculateBranchCoverageByClass associations collect: [:assoc |  | dataExecBranches |\r        dataExecBranches := assoc value.\r        \r        "it contains: number of branches of the methods of a class, and the number of executed branches"dataExecBranches first > 0 ifFalse: [ assoc key -> 0 ] ifTrue: [ assoc key -> ((100 * dataExecBranches second / dataExecBranches first) asFloat round: 3) ] ]) asDictionary',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.333331-04:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLProfilerCoverage			},			#name : #'branchCoverageCriteriaOf:',			#protocol : #calculations,			#sourceCode : 'branchCoverageCriteriaOf: className\r  ^[ self calculateBranchCoverageOf: className ] on: Error do: [ #(0 0 0) ]',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.333778-04:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLProfilerCoverage			},			#name : #calculateBranchCoverageByClass,			#protocol : #calculations,			#sourceCode : 'calculateBranchCoverageByClass\r  ^ (self allClassesAsDictionary keys \r\t\tcollect: [:aClassName |  \r\t\t\taClassName -> (self calculateBranchCoverageOf: aClassName) ] \r\t\tthenSelect: [:assoc |  assoc value second > 0 ]) asDictionary',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.333935-04:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLProfilerCoverage			},			#name : #'calculateBranchCoverageOf:',			#protocol : #calculations,			#sourceCode : 'calculateBranchCoverageOf: symbol\r  | methods numBranches numExecBranches |\r  methods := (self classAt: symbol) allMethods.\r  numBranches := methods ifEmpty: [ 0 ] ifNotEmpty: [ (methods collect: #numberOfBranches) sum ].\r  numExecBranches := methods inject: 0 into: [:sum :method |  sum + method numberOfExecutedBranches ].\r  ^Array with: numBranches with: numExecBranches with: (numBranches > 0 ifTrue: [(numExecBranches / numBranches) asFloat * 100 round: 3] ifFalse: [ 0 ])',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.33457-04:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLProfilerCoverage			},			#name : #'calculateExecutedMethodsOf:',			#protocol : #calculations,			#sourceCode : 'calculateExecutedMethodsOf: aSymbol\r\t| methods |\r\tmethods := (self classAt: aSymbol) allMethods.\r\t^ Array with: methods size with: (self selectExecutedMethods: methods) size',			#stamp : '',			#package : #SpyLite		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLProfilerCoverage			},			#name : #'calculateExecutedMethodsOf:',			#protocol : #calculations,			#sourceCode : 'calculateExecutedMethodsOf: aSymbol\r  | methods nExecMethods nMethods |\r  methods := (self classAt: aSymbol) allMethods.\r  nExecMethods := (self selectExecutedMethods: methods) size.\r  nMethods := methods size.\r  ^Array with: nMethods with: nExecMethods with: (nMethods > 0 ifTrue: [(nExecMethods / nMethods) asFloat * 100 round: 3] ifFalse: [ 0 ])',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.334912-04:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLProfilerCoverage			},			#name : #'calculateExecutedStatementsOf:',			#protocol : #calculations,			#sourceCode : 'calculateExecutedStatementsOf: aSymbol\r\t| methods numStmts |\r\tmethods := (self classAt: aSymbol) allMethods.\r\tnumStmts := methods ifEmpty: [ 0 ] ifNotEmpty: [ (methods collect: #numberOfAllStatements ) sum ].\r\t^ Array with: numStmts with: \r\t   (methods\r\t\tinject: 0\r\t\tinto: [ :sum :method | sum + method numberOfExecutedStatements ])',			#stamp : '',			#package : #SpyLite		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLProfilerCoverage			},			#name : #'calculateExecutedStatementsOf:',			#protocol : #calculations,			#sourceCode : 'calculateExecutedStatementsOf: aSymbol\r  | methods numStmts numExecStatmts |\r  methods := (self classAt: aSymbol) allMethods.\r  numStmts := methods ifEmpty: [ 0 ] ifNotEmpty: [ (methods collect: #numberOfAllStatements) sum ].\r\tnumExecStatmts := methods inject: 0 into: [:sum :method |  sum + method numberOfExecutedStatements ].\r  ^Array with: numStmts with: numExecStatmts with: (numStmts > 0 ifTrue: [ (numExecStatmts / numStmts) * 100 asFloat round: 3 ] ifFalse: [ 0 ])',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.335024-04:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLProfilerCoverage			},			#name : #'calculateOutputCoverageOf:',			#protocol : #calculations,			#sourceCode : 'calculateOutputCoverageOf: symbol\r  | methods colOfBlocks nExecMethods nBranches nMethods |\r  methods := (self classAt: symbol) allMethods.\r  colOfBlocks := methods collect: #blocks thenSelect: #isNotEmpty.\r  nExecMethods := 0.\r  nBranches := 0.\r  nMethods := methods size.\r  colOfBlocks collect: [:blocks |  blocks first wasExecuted ifTrue: [ nExecMethods := nExecMethods + 1.\r              nBranches := nBranches + (blocks size > 1 ifTrue: [ (blocks allButFirst select: #wasExecuted) size / (blocks size - 1) ] ifFalse: [ 1 ]) ] ].\r  ^Array with: nMethods with: nExecMethods with: (nMethods > 0 ifTrue: [ (nBranches / nMethods) asFloat * 100 round: 3 ] ifFalse: [ 0 ])',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.335096-04:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLProfilerCoverage			},			#name : #'methodCoverageCriteriaOf:',			#protocol : #calculations,			#sourceCode : 'methodCoverageCriteriaOf: className\r  ^[ self calculateExecutedMethodsOf: className ] on: Error do: [ #(0 0 0) ]',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.335183-04:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLProfilerCoverage			},			#name : #'outputCoverageCriteriaOf:',			#protocol : #calculations,			#sourceCode : 'outputCoverageCriteriaOf: className\r  ^[ self calculateOutputCoverageOf: className ] on: Error do: [:e | self halt. #(0 0 0) ]',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.33525-04:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLProfilerCoverage			},			#name : #'statementCoverageCriteriaOf:',			#protocol : #calculations,			#sourceCode : 'statementCoverageCriteriaOf: className\r  ^[ self calculateExecutedStatementsOf: className ] on: Error do: [ #(0 0 0) ]',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.336867-04:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CompiledMethod			},			#name : #numberOfLinesOfCode,			#protocol : #'*SpyLite-testing',			#sourceCode : 'numberOfLinesOfCode\r\t^ self linesOfCode',			#stamp : '',			#package : #Roassal3-Examples		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CompiledMethod			},			#name : #numberOfLinesOfCode,			#protocol : #'*SpyLite-testing',			#sourceCode : 'numberOfLinesOfCode\r\t(self propertyValueAt: #numberOfLinesOfCode)\r\t\t\tifNil: [ self propertyValueAt: #numberOfLinesOfCode put: self sourceCode lineCount ].\r\r\t^ self propertyValueAt: #numberOfLinesOfCode ',			#stamp : '',			#package : #Roassal3-Examples		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.338838-04:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CompiledMethod			},			#name : #numberOfLinesOfCode,			#protocol : #'*Roassal3-Examples',			#sourceCode : 'numberOfLinesOfCode\r\t(self propertyValueAt: #numberOfLinesOfCode)\r\t\t\tifNil: [ self propertyValueAt: #numberOfLinesOfCode put: self sourceCode lineCount ].\r\r\t^ self propertyValueAt: #numberOfLinesOfCode ',			#stamp : '',			#package : #SpyLite		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #CompiledMethod			},			#name : #numberOfLinesOfCode,			#protocol : #'*SpyLite-testing',			#sourceCode : 'numberOfLinesOfCode\r\t(self propertyValueAt: #numberOfLinesOfCode)\r\t\t\tifNil: [ self propertyValueAt: #numberOfLinesOfCode put: self sourceCode lineCount ].\r\r\t^ self propertyValueAt: #numberOfLinesOfCode ',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.339886-04:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLMethodCoverage			},			#name : #numberOfBranches,			#protocol : #'public - metrics',			#sourceCode : 'numberOfBranches\r  ^ self blocks size',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:02:20.339959-04:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#isMetaSide : false,				#className : #SLMethodCoverage			},			#name : #numberOfExecutedBranches,			#protocol : #'public - metrics',			#sourceCode : 'numberOfExecutedBranches\r  ^ (self blocks select: #wasExecuted) size',			#stamp : '',			#package : #SpyLite		}	}}OmEntry {	#tags : {		#author : 'Unknown',		#time : DateAndTime [ '2021-11-23T10:03:46.71636-04:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpSessionSnapshot {		#imageName : '/home/andreina/Documents/Github/ArtifactTestEvoViz/NeoJSON.image'	}}